#VRML V2.0 utf8


WorldInfo{
	title "Particles"
	info[
 		"Contact Particle system test with DX11 shader"
	]
}

EXTERNPROTO Particles[
		exposedField SFVec3f bboxSize
		exposedField SFVec3f bboxCenter
		exposedField SFFloat lodRange
		exposedField SFBool enabled
		exposedField SFFloat particleRadius
		exposedField SFFloat particleRadiusVariation
		exposedField SFFloat particleRadiusRate
		exposedField SFNode geometry
		exposedField SFVec3f emitterPosition
		exposedField SFFloat emitterRadius
		exposedField SFFloat emitterSpread
		exposedField SFVec3f emitVelocity
		exposedField SFFloat emitVelocityVariation
		exposedField SFRotation emitterOrientation
		exposedField SFFloat creationRate
		exposedField SFFloat creationRateVariation
		exposedField SFInt32 maxParticles
		exposedField SFTime maxLifeTime
		exposedField SFFloat maxLifeTimeVariation
		exposedField SFVec3f gravity
		exposedField SFVec3f acceleration
		exposedField SFColor emitColor
		exposedField SFFloat emitColorVariation
		exposedField SFNode emitter
		exposedField SFColor fadeColor
		exposedField SFFloat fadeAlpha
		exposedField SFFloat fadeRate
		exposedField SFFloat fadeStartFraction
		exposedField SFInt32 numTrails
		exposedField SFInt32 numSparks
		exposedField SFVec3f sparkGravity
		exposedField SFColor sparkFadeColor
		exposedField SFBool sort
		exposedField SFBool billboard
		exposedField SFString renderMode
		exposedField SFBool emitLocal
		exposedField SFBool directionAlign
		exposedField SFNode metadata
		]
	["urn:inet:bitmanagement.de:node:Particles","http://www.bitmanagement.de/vrml/protos/nodes.wrl#Particles","nodes.wrl#Particles"]


NavigationInfo {
	visibilityLimit 200
}

DEF TS TimeSensor {
	enabled TRUE
	loop TRUE
	cycleInterval 10
}

Viewpoint 
{
	position 0 2.75 35	
	fieldOfView 1.0
	description	"Start"
}

DEF Background Background { skyColor 0 0 0 }
PointLight {
	on FALSE
	location 0 2 0
	color 1 0.05 0.05
}


#DEF Ground Transform {
#	scale 50 50 50
#	children [
#		Shape {
#			appearance Appearance { 
#				material Material { diffuseColor 0 0 0 emissiveColor 1 1 1 transparency 0.2 }
#				texture ImageTexture { url "../textures/gray_ground.jpg" }
#				textureTransform TextureTransform { scale 10 10 }
#			}
#			geometry DEF Square IndexedFaceSet {
#				solid FALSE
#				coord Coordinate {
#					point [ -1 0 -1,
#						1 0 -1,
#						1 0 1,
#						-1 0 1 ]
#				}
#				texCoord TextureCoordinate {
#					point [ 0 0, 
#						1 0,
#						1 1,
#						0 1 ]
#				}
#				coordIndex [ 0, 1, 2, 3, -1 ]
#			}
#		}
#	]
#}


DEF PS-S Shape {
	appearance 	DEF PS-APP Appearance {
		material Material { transparency 0.1  emissiveColor 1 0.5 0.5 }
		texture DEF PS-TEX 
		ImageTexture 
		#MovieTexture 
		{	# loop TRUE speed	2
			repeatS	FALSE repeatT FALSE
			url [
				#"../textures/anim/fire_ani.gif" 
				##"../textures/particle.png" 
				"../textures/particle.png" 
				## "../textures/shine1.png" 
				##"../textures/flare2.png"
			]
		}
			shaders[
			
			
			DEF PSShader PackagedShader {
				language "HLSL"
				technique "SPRITE"

				##exposedField SFFloat Explode 0.2
				field SFNode texture0 USE PS-TEX

				url "hlsl://5_0
//hlsl:5_0 BSContact Shader Generator: numLights=0 numTextures=1 lightingEnable=0 specularEnable=0 doubleSidedEnable=0 fogEnable=0 vertexLighting=1 pixelLighting=0 vertexColor=1 numTextureCoord=1
// Texture enable & type colorType: [0] = 1 t=3 
cbuffer ModelViewProjectionConstantBuffer {
float4x4 World			: WORLD;
float4x4 View			: VIEW;
float4x4 Projection		: PROJECTION;
float4x4 WorldView		: WORLDVIEW;
float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;
float4x4 WorldViewInverseTranspose	: worldViewInverseTranspose;
};
float AlphaRef			 	: alphaRef;
float4 currentColor                 : currentColor;

Texture2D   texture0;
SamplerState samp_texture0;

struct VSOutGS
{
    float4 Position : POSITION;	   //WORLD Space	SV_POSITION
    //float3 Normal	: NORMAL;		   //WORLD Space

 	float4 Color 		: COLOR;
	float2 Texture0 	: TEXCOORD0;
};

struct VSIn
{
	float3 Position		: POSITION;
	float4 Color 		: COLOR;
	float2 Texture0 	: TEXCOORD0;
};

struct VSOut
{
	float4 Position		: SV_POSITION;	
	float4 Color		: COLOR0;
	float2 Texture0		: TEXCOORD0;
};

struct PSIn
{
	float4 sv_position	: SV_POSITION;
	float4 Color  		: COLOR0;
	float2 Texture0		: TEXCOORD0;
};

static const float2 corners[4] =
{
	float2(0.0, 1.0), float2(0.0, 0.0), float2(1.0, 1.0), float2(1.0, 0.0)
};

//		float3( -1, 1, 0 ),	float3( 1, 1, 0 ), float3( -1, -1, 0 ),	 float3( 1, -1, 0 ),

[maxvertexcount(4)]
void SPRITE_GS(point VSIn input[1], inout TriangleStream<VSOut> triStream)
{
	//float4 gl_Position;
	float4 gl_TexCoord[4];

	const float3 corners3[4] =	{ float3( -1, 1, 0 ),	float3( 1, 1, 0 ), float3( -1, -1, 0 ),	 float3( 1, -1, 0 ) };

	{
		[unroll]
		for (int i = 0; i < 4; i++)
			gl_TexCoord[i] = float4(0.0f, 0.0f, 0.0f, 0.0f);
	}

	//const float4x4 gl_ModelViewMatrix = gParams.modelView;
	const float pointRadius = input[0].Texture0.x; // gParams.pointRadius;
	//const float pointScale = gParams.pointScale;

	float4 viewPos = float4(input[0].Position,1.0);
	//float4 viewPos = input[0].Position;

	viewPos = mul(viewPos,WorldView);

	//float4 gl_Vertex = input[0].bounds;	// retrieve gl_Vertex from bounds

	//float spriteSize = pointScale * (pointRadius / gl_Position.w);
	float spriteSize = 10; // 0.2; //pointRadius * 2;

	VSOut output;

	for (int i = 0; i < 4; ++i)
	{

		float4 eyePos = viewPos;								// start with point position
		//eyePos.xy += spriteSize * (corners[i] - float2(0.5, 0.5));	// add corner position
		eyePos.xyz += spriteSize * (corners3[i]);	// add corner position
		//gl_Position = mul(gParams.projection, eyePos);				// complete transformation

		gl_TexCoord[0].xy = corners[i].xy;							// use corner as texCoord
		gl_TexCoord[0].y = 1.0f - gl_TexCoord[0].y;					// flip the y component of uv (glsl to hlsl conversion)
		//gl_TexCoord[1] = mul(gl_ModelViewMatrix, float4(gl_Vertex.xyz, 1.0));

		//output.Position = viewPos; // input[0].Position;
		//output.Position.x += 0.2 * i;

		output.Position = eyePos;
		
		output.Texture0 = gl_TexCoord[0].xy;
		output.Color = input[0].Color;

		triStream.Append(output);
	}
	//triStream.RestartStrip();
}



VSOut SPRITE_VS(VSOut input /*, uint instance : SV_VertexID*/)
{
	VSOut output = (VSOut)0.0;
	//output.Position = mul(float4(input.Position,1.0),WorldViewProjection);
	output.Position = mul(input.Position,Projection);
	output.Texture0	 = float2(0.5,0.5); // input.Texture0;
	output.Color = input.Color;

	//output.Color.r= 	output.Color.g=	output.Color.b = 1.0; //xx	  test 
	return output;
}

float4 SPRITE_PS(in PSIn input) : SV_TARGET
{
	float4 color;
	color=input.Color;
	float4 textureColor0=texture0.Sample(samp_texture0,input.Texture0.xy);
	color *= textureColor0;
	//clip((color.a <= AlphaRef) ? -1.0 : 1.0);
	return color;
}
"
			}
		]

		
	}
	geometry  DEF PS Particles 
	{
		bboxSize -1 -1 -1 


	
	   	geometryType "POINT"  #"SPRITE"	#	   "LINE" 
		lodRange 300 
		particleRadius 0.35
		particleRadiusRate 1.5
		particleRadiusVariation 0.1

		emitColor 0.85 0.15 0.15
		emitColorVariation 0.5

		fadeColor 1 1 0.5

		fadeRate 0.5
		##fadeAlpha 0
		emitterPosition 0 0 0
		emitterRadius 1

		emitterSpread 0.45
		
		creationRate 700

		maxParticles 35000
		maxLifeTime 10

		emitVelocity 4 15 4
		#emitVelocity 15 15 15
		gravity	0 0 0
		emitVelocityVariation 0.25		
		
		
		numTrails 0 #4
		numSparks 0
	}
}






DEF PS-translation PositionInterpolator {
	keyValue [ 0 0 0,  2 0 0, 0 0 0]
}
DEF PS-rate ScalarInterpolator {
	keyValue [ 200  350  1700 200  1000 200  ]
}
DEF PS-spread ScalarInterpolator {
	keyValue [ 0.25 0.75 0.3 0.1 0.25 ]
}

ROUTE TS.fraction_changed TO PS-translation.set_fraction
ROUTE PS-translation.value_changed TO PS.emitterPosition

ROUTE TS.fraction_changed TO PS-rate.set_fraction
ROUTE PS-rate.value_changed TO PS.creationRate
ROUTE TS.fraction_changed TO PS-spread.set_fraction
ROUTE PS-spread.value_changed TO PS.emitterSpread



