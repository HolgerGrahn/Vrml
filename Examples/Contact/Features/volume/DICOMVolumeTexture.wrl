#VRML V2.0 utf8

EXTERNPROTO Layer2D [
	exposedField MFNode children
	exposedField SFVec2f translation
	exposedField SFVec2f size
	exposedField SFNode background
	exposedField SFNode viewport
	eventIn MFNode addChildren
	eventIn MFNode removeChildren
]
[ "urn:inet:blaxxun.com:node:Layer2D","http://www.blaxxun.com/vrml/protos/nodes.wrl#Layer2D" ]



WorldInfo {
	title "DICOM "
	info [
		"DICOM Volume map"
		"Slices are rendered back to front depending on view direction"
		"and blended together with some transparency setting"
		"Further Ideas:"
		" - Coloring in pixel shader"
		" - clipping via additional texture, clipplanes etc"
		"options:relativeTime=true,wwwProgress=true"

	  	"(c) 2004-2018 Holger Grahn - hg @ snafu.de"	
	]
}
EXTERNPROTO MultiTexture[
	exposedField SFBool materialColor
	exposedField SFBool materialAlpha
	exposedField SFBool transparent
	exposedField SFBool nomipmap
	exposedField MFString mode
	exposedField MFString type
	exposedField MFNode texture
	exposedField MFNode textureTransform
	exposedField MFNode bumpTransform
	exposedField MFInt32 textureOp
	exposedField SFColor color
	exposedField SFFloat alpha
]
["urn:inet:bitmanagement.de:node:MultiTexture","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MultiTexture","nodes.wrl#MultiTexture"]
EXTERNPROTO BumpTransform[
	exposedField SFVec2f s
	exposedField SFVec2f t
	exposedField SFVec2f l
]
["urn:inet:bitmanagement.de:node:BumpTransform","http://www.bitmanagement.de/vrml/protos/nodes.wrl#BumpTransform","nodes.wrl#BumpTransform"]

EXTERNPROTO MultiTextureCoordinate[
	exposedField MFNode coord
]
["urn:inet:bitmanagement.de:node:MultiTextureCoordinate","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MultiTextureCoordinate","nodes.wrl#MultiTextureCoordinate"]

EXTERNPROTO Rectangle [
    exposedField SFVec2f size 
]
["urn:inet:bitmanagement.de:node:Rectangle","http://www.bitmanagement.de/vrml/protos/nodes.wrl#Rectangle","nodes.wrl#Rectangle"]

EXTERNPROTO DrawGroup[
	exposedField SFVec3f bboxSize
	exposedField SFVec3f bboxCenter
	exposedField SFNode metadata
	exposedField SFBool sortedAlpha
	exposedField SFBool restoreOp
	exposedField MFNode drawOp
	exposedField SFString path
	exposedField SFBool sortAlphaInGroup
	exposedField MFNode children
	eventIn MFNode addChildren
	eventIn MFNode removeChildren
]
["urn:inet:bitmanagement.de:node:DrawGroup","http://www.bitmanagement.de/vrml/protos/nodes.wrl#DrawGroup","nodes.wrl#DrawGroup"]

EXTERNPROTO Selection[
	exposedField SFVec3f bboxSize
	exposedField SFVec3f bboxCenter
	exposedField SFNode metadata
	exposedField SFBool collide
	exposedField SFBool select
	exposedField SFNode proxy
	exposedField MFNode children
	eventIn MFNode addChildren
	eventIn MFNode removeChildren
]
["urn:inet:bitmanagement.de:node:Selection","http://www.bitmanagement.de/vrml/protos/nodes.wrl#Selection","nodes.wrl#Selection"]



# drag/drop
EXTERNPROTO DropHandler [
	field SFNode root  
	field SFNode rootShape 

] "../event/drop/drophandler.wrl#DropHandler"

# scroll transparency 
EXTERNPROTO Slider [#slightly modified version
	exposedField MFNode arrow_geometry
    exposedField SFFloat min
    exposedField SFFloat max
    exposedField SFFloat pageSize
	exposedField SFString description  # hg 

    eventIn  SFFloat     set_position
    field    SFFloat initial_position
    eventOut SFFloat         position_changed 
    eventOut SFInt32         positionInt_changed
    eventIn  SFFloat            silently_set_position
    eventIn  SFFloat silently_set_unfiltered_position   
    eventIn  SFFloat          set_unfiltered_position
    eventOut SFFloat              unfiltered_position_changed
    eventOut SFFloat                    knob_position_changed
    exposedField SFFloat height
    exposedField SFFloat radiusKnob
    exposedField SFFloat radiusStick
    exposedField SFNode appearance
] [
	"proto_Slider.wrl#Slider"
	"../../labs/inlines/proto_Slider.wrl#Slider"
]


EXTERNPROTO MetadataSet[
	exposedField SFNode metadata
	exposedField SFString name
	exposedField SFString reference
	exposedField MFNode value
]
["urn:inet:bitmanagement.de:node:MetadataSet","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MetadataSet","nodes.wrl#MetadataSet"]
EXTERNPROTO MetadataString[
	exposedField SFNode metadata
	exposedField SFString name
	exposedField SFString reference
	exposedField MFString value
]
["urn:inet:bitmanagement.de:node:MetadataString","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MetadataString","nodes.wrl#MetadataString"]

EXTERNPROTO MetadataDouble[
	exposedField SFNode metadata
	exposedField SFString name
	exposedField SFString reference
	exposedField MFDouble value
]
["urn:inet:bitmanagement.de:node:MetadataDouble","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MetadataDouble","nodes.wrl#MetadataDouble"]
EXTERNPROTO MetadataInteger[
	exposedField SFNode metadata
	exposedField SFString name
	exposedField SFString reference
	exposedField MFInt32 value
]
["urn:inet:bitmanagement.de:node:MetadataInteger","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MetadataInteger","nodes.wrl#MetadataInteger"]

EXTERNPROTO PixelTexture3D[
	exposedField SFNode metadata
	exposedField SFBool repeatS
	exposedField SFBool repeatT
	exposedField SFBool repeatR
	exposedField MFInt32 image
	exposedField SFNode textureProperties
]
["urn:inet:bitmanagement.de:node:PixelTexture3D","http://www.bitmanagement.de/vrml/protos/nodes.wrl#PixelTexture3D","nodes.wrl#PixelTexture3D"]
EXTERNPROTO TextureMatrixTransform[
	exposedField SFMatrix matrix
	exposedField SFNode metadata
]
["urn:inet:bitmanagement.de:node:TextureMatrixTransform","http://www.bitmanagement.de/vrml/protos/nodes.wrl#TextureMatrixTransform","nodes.wrl#TextureMatrixTransform"]

EXTERNPROTO DICOMTexture[
	exposedField SFNode metadata
	exposedField MFString url
	exposedField SFInt32 selected
	eventOut SFBool isLoaded
	exposedField MFNode texture
	exposedField SFNode volumeTexture
	exposedField SFNode transferTexture
	exposedField SFVec3f volumeCenter
	exposedField SFVec3f volumeSize
	exposedField SFVec3f volumeSizePixel
	exposedField SFNode volumeGeometry
	exposedField SFInt32 volumeStyle
	exposedField SFBool computeGradient
	eventOut SFBool hasGradient
	exposedField SFInt32 numSlices
	exposedField SFVec2f sliceRange
	exposedField MFVec4f colorCurvePoints
	exposedField MFVec2f alphaCurvePoints
	exposedField MFString parameter
	exposedField SFNode textureProperties
	]
["urn:inet:bitmanagement.de:node:DICOMTexture","http://www.bitmanagement.de/vrml/protos/nodes.wrl#DICOMTexture","nodes.wrl#DICOMTexture"]


DEF UserViewpoint:1 Viewpoint {
	fieldOfView 0.7853916
	orientation 0.9985303 0.02253395 0.04929062 0.9964047
	position 0.1472713 -2.98221 1.933303
	description "UserViewpoint:1"
}
DEF UserViewpoint:2 Viewpoint {
	fieldOfView 0.7853885
	orientation 0.6905264 0.3801786 0.6153353 1.752684
	position 3.122813 -1.428292 0.9409164
	description "UserViewpoint:2"
}



DEF dicom DICOMTexture {

	url "../textures/VolumeMaps/HeadVolume.dds"

#	url "E:\\DICOMDIR"

#	url "VolumeMaps/VisMale.raw"
#	url "VolumeMaps/VisMale.Gradient.dds"


	selected -1

	volumeCenter 0 0 0
	volumeSize 2 2 2

   	volumeStyle 0	##  0 Slice , 1  box ,	2,3 one slice 


	numSlices 128	   # for mode 0 
	sliceRange 0.0 1.0   # for mode 2,3 sliceRange.y is used for the slice 

	computeGradient TRUE #  FALSE	  # TRUE   # compute gradient if data loaded from DICOM, for DDS assume formats D3DFMT_A16B16G16R16F and D3DFMT_A32B32G32R32F have normal + intensity

	# default values 
	colorCurvePoints [0.91 0.7 0.61 0,0.91 0.7 0.61 0.3125,1 1 0.85 0.3203125,1 1 0.85 1]
	alphaCurvePoints [0 0,0 0.15625,0.2 0.234375,0.05 0.2460938,0 0.3125,0.9 0.3203125,1 1]

	#0.35 skin start 
##	colorCurvePoints [0 0 0 0, 0 0 0 0.35, 1  0.5 0.5 0.4,	1 0.5 0.5 0.8,	1 1 1 1.0]
##	alphaCurvePoints [ 0 0,    0 0.35, 1 0.4, 1 0.8 1 1]

	parameter ["saveDDS=false"]		   # false


}

## basic  shader 

DEF	Shaders Switch {
	whichChoice	-1
	choice [

DEF BasicVolumeShader PackagedShader 
{

	exposedField SFVec2f	   intensityWindow 0.1 1.0

	language "FX"


	url "fx:

	const bool isGradientTexture = false; // true;	   // if R16G16B16A16F, normal + intensity
   	const bool useTransferTexture = false;
	const bool useShading =false;
	//CONFIG END

	static const float3 lightDir = float3(1,1,1);

	// Contact state parameters
	float4x4 World                  	: WORLD;
	float4x4 WorldViewProj          	: WORLDVIEWPROJECTION;
	float4x4 WorldView                	: worldView;
	float4x4 WorldViewInverseTranspose	: worldViewInverseTranspose;
	float4   Color              		: currentColor;

	// custom parameters

	float2 intensityWindow; // range of gray values



	texture   texture0 : register( t0 );
	sampler3D samp_texture0 : register( s0 );
	float4x4 textureMatrix0 : texture0;

	// transfer function lookup 
	texture   texture1 : register( t1 );
   	sampler2D samp_texture1 : register( s1 );


	struct VSIn
	{
	float3 Position  	: POSITION;
	//float3 Normal   	: NORMAL;
	float3 Texture0 	: TEXCOORD0;
	};

	struct VSOut
	{
	float4 Position : POSITION;
	//float3 Normal 	: TEXCOORD1;
	//float3 EyeVector	: TEXCOORD2;
	float4 Color	: COLOR0;
	float3 Texture0	: TEXCOORD0;
	};

	struct PSIn
	{
	//float3 Normal 	: TEXCOORD1;
	//float3 EyeVector	: TEXCOORD2;
	float4 Color    	: COLOR0;
	float3 Texture0	: TEXCOORD0;
	};

	VSOut VS(VSIn input)
	{
		VSOut output = (VSOut)0.0;
		output.Position = mul(float4(input.Position, 1.0),WorldViewProj);
		//float3 positionView =mul(float4(input.Position,1.0),WorldView).xyz;
		//float3 eyeVector = normalize(-positionView);
		//float3 normal = normalize(mul(input.Normal,(float3x3)WorldViewInverseTranspose));
		output.Texture0	 = mul(float4(input.Texture0,1.0f),textureMatrix0).xyz;
		output.Color = Color;	  // from material 
		return output;
	}
	float4 PS(in PSIn input) : COLOR
	{
		float4 color=input.Color;
		float intensity;
   		float lightIntensity=1.0;

		 // lookup volume 
		float4 textureColor0=tex3D(samp_texture0,input.Texture0.xyz);



		if (isGradientTexture) {
			intensity = textureColor0.a; // Gradient  Texture 

			if (useShading) {
				float3 normal=	textureColor0.rgb; // *2.0-1.0;
	
				lightIntensity = abs(dot(normal,lightDir));	 
				//return float4(intensity* lightIntensity,intensity* lightIntensity,lightIntensity,color.a);
   
				//return float4(textureColor0.rgb,intensity*color.a); // show gradient
			}
		}
		// texture is just grayscale
  		else intensity = textureColor0.r; // gray Texture 
	
		if (useTransferTexture) {
			// use transfer functions
			float4 colorLookup = tex2Dlod(samp_texture1,float4(intensity,0.0,0.0,0.0));

			intensity = colorLookup.a;   // mm give not expected result 
			
			intensity =  (intensity - intensityWindow.x)/ (intensityWindow.y-intensityWindow.x);

			color.rgb *= lightIntensity * colorLookup.rgb * intensity;
		}
		else {
  			// add scaling and clipping to window 
			intensity =  (intensity - intensityWindow.x)/ (intensityWindow.y-intensityWindow.x);

			color.rgb *= lightIntensity *float3(intensity,intensity,intensity);	    
			//color.rgb=textureColor0.rgb*color.rgb;
			//color.a=textureColor0.a*color.a;	  
		}

 
		clip(((intensity<=0.01 ) || (intensity>1.0)) ? -1.0 : 1.0);	

	return color;
	}
	technique Render
	{
	pass p0
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS();
	}
	}
	"
}



DEF BasicVolumeShaderRayCast00 PackagedShader 
{

	exposedField SFVec2f	   intensityWindow 0.1 1.0

	language "00FX"			  


	url "fx:
	const bool isGradientTexture = false; // true;	   // false:grayscale  true  R16G16B16A16F, normal + intensity
	const bool useTransferTexture = false;
	const bool useShading =false;
	//static const uint numSteps = 20;
	//static const uint numSteps = 100;
	static const uint numSteps = 64;//128;	 hg : 128 too much with gradient for my card 

	//CONFIG END
	static const float3 step = float3(1.0/float(numSteps),1.0/float(numSteps),1.0/float(numSteps));	// sampling step 
	static const float3 lightDir = float3(1,1,-1);



	// custom parameters
	float2 intensityWindow; // range of gray values


	// Contact state parameters
	float4x4 World                  	: WORLD;
	float4x4 WorldViewProj          	: WORLDVIEWPROJECTION;
	float4x4 WorldView                	: worldView;
	float4x4 WorldViewInverseTranspose	: worldViewInverseTranspose;
	float4   Color              		: currentColor;


	float3   viewPosition				: VIEWPOSITION; // in world space 



	texture   texture0 : register( t0 );

	float4x4 textureMatrix0 : texture0;

	sampler3D samp_texture0 : register( s0 );

	sampler3D samp_texture0_border = sampler_state
	{
		Texture = <texture0>;
		MinFilter = LINEAR;
		MagFilter = LINEAR;
		MipFilter = LINEAR;
	
		AddressU = Border;				// border sampling in U
    	AddressV = Border;				// border sampling in V
    	AddressW = Border;
    	BorderColor = float4(1,0,0,1.0);	// outside of border should be black	// hg idea use for loop exit
	};

	// transfer function lookup 
	texture   texture1 : register( t1 );
   	sampler2D samp_texture1 : register( s1 );


	struct VSIn
	{
	float3 Position  	: POSITION;
	float3 Normal   	: NORMAL;
	float3 Texture0 	: TEXCOORD0;
	};

	struct VSOut
	{
	float4 Position : POSITION;

	float3 Texture0	: TEXCOORD0;

	float3 Normal 	: TEXCOORD1;

	float3 PositionWorld : TEXCOORD2;
	//float3 PositionEye : TEXCOORD3;
	float4 Color	: COLOR0;
	};

	struct PSIn
	{
	float3 Normal 		: TEXCOORD1;
	float3 PositionWorld : TEXCOORD2;
	//float3 EyeVector	: TEXCOORD2;
	float4 Color    	: COLOR0;
	float3 Texture0		: TEXCOORD0;
	};

	VSOut VS(VSIn input)
	{
		VSOut output = (VSOut)0.0;
		output.Position = mul(float4(input.Position, 1.0),WorldViewProj);
		float3 positionView =mul(float4(input.Position,1.0),WorldView).xyz;
		float3 eyeVector = normalize(-positionView);

		//output.PositionView = positionView;
		output.PositionWorld = mul(float4(input.Position,1.0),World).xyz;
	
		//float3 normal = normalize(mul(input.Normal,(float3x3)WorldViewInverseTranspose));
		output.Texture0	 = mul(float4(input.Texture0,1.0f),textureMatrix0).xyz;
		output.Color = Color;
		return output;
	}
	float4 PS(in PSIn input) : COLOR
	{
		float4 color;
		color=input.Color;


		float3 eye = float3(0,0,0);
	


		float3 rayPosition=  input.Texture0.xyz;
		//float3 rayDirection= normalize(-input.PositionView);
	
		float3 rayDirection= -normalize(viewPosition - input.PositionWorld);

		float4 colorSum= float4(0,0,0,0);
		float intensity;


		//return float4(rayDirection*0.5 +0.5,1.0);
		//rayDirection = float3(0,0,-1);

		rayDirection*=step;

		[loop]for (uint i=0; i<numSteps; i++)
		{
  			// texture is just grayscale

			//float4 textureColor0=tex3D(samp_texture0,rayPosition);	// not working with loop
			float4 textureColor0=tex3Dlod(samp_texture0,rayPosition);
			//if (textureColor0.a<0.0)
			//	break;
			float intensity;
			float lightIntensity=1.0;
			if (isGradientTexture) 
			{
				intensity = textureColor0.a; // Gradient  Texture 

				if (useShading) {
					float3 normal= textureColor0.rgb; // *2.0-1.0;
			
					lightIntensity = abs(dot(normal,lightDir)); // ,0.0,1.0);	 // abs	clamp
					//return float4(v,v,v,intensity*color.a);
   
					////return float4(textureColor0.rgb,intensity*color.a); // show gradient
				}
			}
			else  
				intensity = textureColor0.r;

			if (useTransferTexture) 
			{
				// use transfer functions

				float4 colorLookup = tex2D(samp_texture1,float2(intensity,0.0));
				intensity = colorLookup.a;
				// interesting ?
				intensity =  clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);
				colorLookup.a *= color.a; // use transparency from slider 

				//clip((intensity<=0.01) ? -1.0 : 1.0);
				colorLookup.rgb *= lightIntensity * intensity;
				colorSum = (1.0f - colorSum.a)*colorLookup + colorSum;
				// not much helpfull colorSum.a *= color.a; // material 

			//src.a = intensity;	  // funny
			//	colorLookup.rgb *= colorLookup.a * lightIntensity;
				//clip(srccolorLookupa<=0.01  ? -1.0 : 1.0);
			//	colorSum = (1.0f - colorSum.a)*colorLookup + colorSum;
			}
			else {

				// add scaling and clipping  to window 
				//intensity =  (intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x);
				intensity =  clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);
	 
				//float4 src = (float4)intensity;
				float4 src = float4(lightIntensity,lightIntensity,lightIntensity,intensity);
				//src.a *= .5f; //reduce the alpha to have a more transparent result
				src.a *= color.a; // use transparency from slider 

				//Front to back blending
				// dst.rgb = dst.rgb + (1 - dst.a) * src.a * src.rgb
				// dst.a   = dst.a   + (1 - dst.a) * src.a
				src.rgb *= src.a;
				colorSum = (1.0f - colorSum.a)*src + colorSum;

		    	//	color.a   = density * sample_step * val_threshold * brightness;
				//intensity *= step.x;

//xx		    colorSum.rgb = colorSum.rgb * (1.0 - intensity) +  float3(intensity,intensity,intensity)  * lightIntensity;
//xx			colorSum.a += intensity*step.x;
			}
			rayPosition += rayDirection;

			if (colorSum.a>=0.97 || rayPosition.x > 1.0f || rayPosition.y > 1.0f || rayPosition.z > 1.0f
				|| rayPosition.x < 0.0f || rayPosition.y < 0.0f || rayPosition.z < 0.0f)
				break;

		}
	
	color = colorSum;
//xx		color.rgb = colorSum.rgb;
//xx		color.a *= colorSum.a;

		intensity = colorSum.a;
	    //color.a = 0.0; // test 

		clip((intensity<=0.01 /*|| intensity>1.0*/) ? -1.0 : 1.0);
		//color.rgb *= float3(intensity,intensity,intensity);	    

		return color;
	}

	technique Render
	{
	pass p0
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS();
	}
	}
	"
}


DEF BasicVolumeShaderRayCast PackagedShader 
{

	exposedField SFVec2f	   intensityWindow 0.1 1.0

	language "FX"


	url "fx:
	const bool isGradientTexture = false; // true;	   // false:grayscale  true  R16G16B16A16F, normal + intensity
	const bool useTransferTexture = false;
	const bool useShading =false;
	//static const uint numSteps = 20;
	//static const uint numSteps = 100;
	static const int numSteps = 128;	 //hg : 128 too much with gradient for my card		< ps3 want int 

	//CONFIG END

	static const float3 step = float3(1.0/float(numSteps),1.0/float(numSteps),1.0/float(numSteps));	// sampling step 
	static const float3 lightDir = float3(1,1,-1);



	// custom parameters
	float2 intensityWindow; // range of gray values


	// Contact state parameters
	float4x4 World                  	: WORLD;
	float4x4 WorldViewProj          	: WORLDVIEWPROJECTION;
	float4x4 WorldView                	: worldView;
	float4x4 WorldViewInverseTranspose	: worldViewInverseTranspose;
	float4   Color              		: currentColor;


	float3   viewPosition				: VIEWPOSITION; // in world space 



	texture   texture0 : register( t0 );

	float4x4 textureMatrix0 : texture0;

	sampler3D samp_texture0 : register( s0 );

	sampler3D samp_texture0_border = sampler_state
	{
		Texture = <texture0>;
		MinFilter = LINEAR;
		MagFilter = LINEAR;
		MipFilter = LINEAR;
	
		AddressU = Border;				// border sampling in U
    	AddressV = Border;				// border sampling in V
    	AddressW = Border;
    	BorderColor = float4(1,0,0,1.0);	// outside of border should be black	// hg idea use for loop exit
	};

	// transfer function lookup 
	texture   texture1 : register( t1 );
   	sampler2D samp_texture1 : register( s1 );


	struct VSIn
	{
	float3 Position  	: POSITION;
	float3 Normal   	: NORMAL;
	float3 Texture0 	: TEXCOORD0;
	};

	struct VSOut
	{
	float4 Position : POSITION;
 	float3 Texture0	: TEXCOORD0;
 	//float3 Normal 	: TEXCOORD1;
 	float3 PositionWorld : TEXCOORD1;
	//float3 PositionEye : TEXCOORD3;
	float4 Color	: COLOR0;
	};

	struct PSIn
	{
	//float3 Normal 		: TEXCOORD1;
	float3 PositionWorld : TEXCOORD1;
	//float3 EyeVector	: TEXCOORD2;
	float4 Color    	: COLOR0;
	float3 Texture0		: TEXCOORD0;
	};

	VSOut VS(VSIn input)
	{
		VSOut output = (VSOut)0.0;
		output.Position = mul(float4(input.Position, 1.0),WorldViewProj);
		float3 positionView =mul(float4(input.Position,1.0),WorldView).xyz;
		float3 eyeVector = normalize(-positionView);

		//output.PositionView = positionView;
		output.PositionWorld = mul(float4(input.Position,1.0),World).xyz;
	
		//float3 normal = normalize(mul(input.Normal,(float3x3)WorldViewInverseTranspose));
		output.Texture0	 = mul(float4(input.Texture0,1.0f),textureMatrix0).xyz;
		output.Color = Color;
		return output;
	}
	float4 PS(in PSIn input) : COLOR
	{
		float4 color;
		color=input.Color;
	
		float4 rayPosition=  float4(input.Texture0.xyz,0.0);
		//rayPosition.w = 0.0; // mip level
		//float3 rayDirection= normalize(-input.PositionView);
	
		float3 rayDirection= -normalize(viewPosition - input.PositionWorld);
		rayDirection*=step;

		float4 colorSum= float4(0,0,0,0);
		float intensity;
	    const bool isoSurface=false;

  		[loop]for (int i=0; i<numSteps; i++)
		{
  			// lookup volume 
   			//float4 textureColor0=tex3D(samp_texture0,rayPosition);  // not working with loop
			float4 textureColor0=tex3Dlod(samp_texture0,rayPosition);
	
			float lightIntensity=1.0;

			if (isGradientTexture) 
			{
				intensity = textureColor0.a; // Gradient  Texture 

				if (useShading) {
					float3 normal= textureColor0.rgb; // *2.0-1.0;
			
					lightIntensity = clamp(dot(normal,lightDir),0.0,1.0);	 
					//return float4(v,v,v,intensity*color.a);
   
					////return float4(textureColor0.rgb,intensity*color.a); // show gradient
				}
			}
			else  
				intensity = textureColor0.r;

			if (useTransferTexture) 
			{
				// use transfer functions

				float4 src = tex2Dlod(samp_texture1,float4(intensity,0.0,0.0,0.0));
			    intensity = src.a;
  				intensity =  clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);
			
				src.a = intensity * color.a; // use transparency from slider 

				// Diffuse shading and fake ambient lighting
				src.rgb = lightIntensity * src.rgb + 0.1f * src.rgb;

				// Front to back blending
				src.rgb *= src.a;
				colorSum += (1 - colorSum.a) * src;

	/*
				intensity = src.a;
				// interesting ?
				intensity =  clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);
				src.a *= color.a; // use transparency from slider 

				//clip((intensity<=0.01) ? -1.0 : 1.0);
				src.rgb *= lightIntensity * intensity;
				colorSum = (1.0f - colorSum.a)*src + colorSum;
				// not much helpfull colorSum.a *= color.a; // material 

			//src.a = intensity;	  // funny
			//	colorLookup.rgb *= colorLookup.a * lightIntensity;
				//clip(srccolorLookupa<=0.01  ? -1.0 : 1.0);
			//	colorSum = (1.0f - colorSum.a)*colorLookup + colorSum;
	*/
			}
			else {

				// add scaling and clipping  to window 
				//intensity =  (intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x);
				if (isoSurface)	{
					if (intensity < intensityWindow.x || intensity > intensityWindow.y) 
						intensity=0.0; 
					else intensity = 1.0;
				}
				else { 
					intensity = clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);
				}
	 
				//float4 src = (float4)intensity;
				float4 src = float4(lightIntensity,lightIntensity,lightIntensity,intensity);
				//src.a *= .5f; //reduce the alpha to have a more transparent result
				src.a *= color.a; // use transparency from slider 

				//Front to back blending
				// dst.rgb = dst.rgb + (1 - dst.a) * src.a * src.rgb
				// dst.a   = dst.a   + (1 - dst.a) * src.a
				src.rgb *= src.a;
				colorSum += (1.0f - colorSum.a)*src;

		    	//	color.a   = density * sample_step * val_threshold * brightness;
				//intensity *= step.x;

//xx		    colorSum.rgb = colorSum.rgb * (1.0 - intensity) +  float3(intensity,intensity,intensity)  * lightIntensity;
//xx			colorSum.a += intensity*step.x;
			}
			rayPosition.xyz += rayDirection;

			if (colorSum.a>=0.97 || rayPosition.x > 1.0f || rayPosition.y > 1.0f || rayPosition.z > 1.0f
				|| rayPosition.x < 0.0f || rayPosition.y < 0.0f || rayPosition.z < 0.0f)
				break;

		}
	
	color = colorSum;
//xx		color.rgb = colorSum.rgb;
//xx		color.a *= colorSum.a;

		intensity = colorSum.a;
	    //color.a = 0.0; // test 

//		clip((intensity<=0.01 /*|| intensity>1.0*/) ? -1.0 : 1.0);
		//color.rgb *= float3(intensity,intensity,intensity);	    

		return color;
	}

	technique Render
	{
	pass p0
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS();
	}
	}
	"
}



DEF BasicVolumeShaderDX11 PackagedShader 
{

	exposedField SFVec2f	   intensityWindow 0.1 1.0

	language "HLSL"


	url "hlsl://hlsl:4.1 BSContact Shader Generator
	static const bool isGradientTexture = false; // true // false:grayscale ,rue  R16G16B16A16F, normal + intensity
	static const bool useTransferTexture = false;	// RGB Intensity lookup
	static const bool useShading =false;
	static const uint numSteps = 64;//128;

	//CONFIG END
	static const float3 step = float3(1.0/float(numSteps),1.0/float(numSteps),1.0/float(numSteps));	// sampling step 
	static const float3 lightDir = float3(1,1,1);


	// Contact state parameters
	cbuffer ModelViewProjectionConstantBuffer {
	float4x4 World	 		: WORLD;
	float4x4 View	     		: VIEW;
	float4x4 Projection		: PROJECTION;
	float4x4 WorldView 		: WORLDVIEW;
	float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;
	float4x4 WorldViewInverseTranspose	: worldViewInverseTranspose;
	};
	//float AlphaRef			 	: alphaRef;
	float4 currentColor         : currentColor;


	// custom parameters

	float2 intensityWindow; // range of gray values



	Texture3D   texture0;
	SamplerState samp_texture0;
	float4x4 textureMatrix0 : texture0;
	
	// transfer function lookup 
	Texture2D   texture1;
   	SamplerState samp_texture1;


	struct VSIn
	{
		float3 Position		: POSITION;
		float3 Texture0 	: TEXCOORD0;
	};

	struct VSOut
	{
		float4 Position		: SV_POSITION;
		//float3 Normal		: TEXCOORD1;
		//float3 EyeVector	: TEXCOORD2;
		float4 Color		: COLOR0;
		float3 Texture0		: TEXCOORD0;
	};

	struct PSIn
	{
		float4 sv_position	: SV_POSITION;
		//float3 Normal 		: TEXCOORD1;
		//float3 EyeVector	: TEXCOORD2;
		float4 Color  		: COLOR0;
		float3 Texture0		: TEXCOORD0;
	};

	VSOut VS(VSIn input)
	{
		VSOut output = (VSOut)0.0;
		output.Position = mul(float4(input.Position,1.0),WorldViewProjection);
		output.Texture0	 = mul(float4(input.Texture0,1.0f),textureMatrix0).xyz;
		output.Color = currentColor;
		return output;
	}
	float4 PS(in PSIn input) : SV_TARGET
	{
		float4 color;
		color=input.Color;
		float4 diffuse=color;
		float intensity;
   		float lightIntensity=1.0;

		// lookup volume 
		float4 textureColor0=texture0.Sample(samp_texture0,input.Texture0.xyz);





		if (isGradientTexture) 
		{
			intensity = textureColor0.a; // Gradient  Texture 
	
			if (useShading) {
				//intensity =  (intensity - intensityWindow.x)/ (intensityWindow.y-intensityWindow.x);

				//clip((intensity<=0.01) ? -1.0 : 1.0);
				float3 normal=	textureColor0.rgb; // *2.0-1.0;
	
				lightIntensity = abs(dot(normal,lightDir));	 // abs
				//return float4(intensity* lightIntensity,intensity* lightIntensity,lightIntensity,color.a);
   
				//return float4(textureColor0.rgb,intensity*color.a); // show gradient
			}
		}
		// texture is just grayscale
  		else intensity = textureColor0.r; // gray Texture 

		if (useTransferTexture) {
			// use transfer functions
			float4 colorLookup = texture1.Sample(samp_texture1,float2(intensity,0.0));
			intensity = colorLookup.a;	 // mm 
			// interesting ?
			intensity =  clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);

			color.rgb *= lightIntensity * colorLookup.rgb * intensity;
			//clip(color.a<=0.01  ? -1.0 : 1.0);
		}
		else 
		{
			// add scaling and clipping to window 
			intensity =  (intensity - intensityWindow.x)/ (intensityWindow.y-intensityWindow.x);

 			color.rgb *= lightIntensity * float3(intensity,intensity,intensity);	    
		}

		clip(((intensity<=0.01 ) || (intensity>1.0)) ? -1.0 : 1.0);	

		//clip((color.a <= AlphaRef) ? -1.0 : 1.0);
		return color;
	}

	"
}

DEF BasicVolumeShaderRayCastDX11 PackagedShader 
{

	exposedField SFVec2f	   intensityWindow 0.1 1.0

	language "HLSL"


	url "hlsl://hlsl:4.1 BSContact Shader Generator
	static const bool isGradientTexture = false; // true;	   // false:grayscale  true  R16G16B16A16F, normal + intensity
	static const bool useTransferTexture = false;
	static const bool useShading =false;
	static const uint numSteps = 64;//128;	 hg : 128 too much with gradient for my card 

	//CONFIG END

	//static const uint numStepsMax = 512;

	// Diagonal of a unit cube has length sqrt(3)
	//static const float StepSize = sqrt(3.f)/numStepsMax;


	static const float3 step = float3(1.0/float(numSteps),1.0/float(numSteps),1.0/float(numSteps));	// sampling step 
	static const float3 lightDir = float3(1,1,-1);


	// Contact state parameters
	cbuffer ModelViewProjectionConstantBuffer {
		float4x4 World	 		: WORLD;
		float4x4 View	     	: VIEW;
		float4x4 Projection		: PROJECTION;
		float4x4 WorldView 		: WORLDVIEW;
		float4x4 WorldViewProjection	: WORLDVIEWPROJECTION;
		float4x4 WorldViewInverseTranspose	: worldViewInverseTranspose;
	};
	//float AlphaRef			 	: alphaRef;
	float4 currentColor         : currentColor;
    float3 viewPosition			: VIEWPOSITION; // in world space 


	// custom parameters

	float2 intensityWindow; 	// range of gray values



	Texture3D   texture0;
	SamplerState samp_texture0;
	float4x4 textureMatrix0 : texture0;
	
	// transfer function lookup 
	Texture2D   texture1;
   	SamplerState samp_texture1;


	struct VSIn
	{
		float3 Position		: POSITION;
		float3 Texture0 	: TEXCOORD0;
	};

	struct VSOut
	{
		float4 Position		: SV_POSITION;
		//float3 Normal		: TEXCOORD1;
		//float3 EyeVector	: TEXCOORD2;
		float4 Color		: COLOR0;
		float3 Texture0		: TEXCOORD0;
		float3 PositionWorld : TEXCOORD1;
	};

	struct PSIn
	{
		float4 sv_position	: SV_POSITION;
		//float3 Normal 		: TEXCOORD1;
		//float3 EyeVector	: TEXCOORD2;
		float4 Color  		: COLOR0;
		float3 Texture0		: TEXCOORD0;
		float3 PositionWorld : TEXCOORD1;
	};

	VSOut VS(VSIn input)
	{
		VSOut output = (VSOut)0.0;
		output.Position = mul(float4(input.Position,1.0),WorldViewProjection);
		output.PositionWorld = mul(float4(input.Position,1.0),World).xyz;
		output.Texture0	 =	input.Texture0;
		//output.Texture0	 = mul(float4(input.Texture0,1.0f),textureMatrix0).xyz;
		output.Color = currentColor;
		return output;
	}
	float4 PS(in PSIn input) : SV_TARGET
	{
		float4 color=input.Color;	 // output color 

		float3 rayPosition=  input.Texture0.xyz;
		float3 rayDirection= -normalize(viewPosition - input.PositionWorld);
   	
		rayDirection*=step;

		float4 colorSum= float4(0,0,0,0);

		float intensity;

		//[fastopt]
		[loop]for (uint i=0; i<numSteps; i++)
		//[fastopt]for (uint i=0; i<numStepsMax; i++)	   // take forever to compile
	    //while (true)	 // compiler wants to unroll ???
		{
  
			// lookup volume 
			float4 textureColor0=texture0.Sample(samp_texture0,rayPosition);

     		float lightIntensity=1.0;

			if (isGradientTexture) 
			{
				intensity = textureColor0.a; // Gradient  Texture 
	
				if (useShading) {
					float3 normal=	textureColor0.rgb; // *2.0-1.0;
	
					lightIntensity = clamp(dot(normal,lightDir),0.0,1.0);	 // abs
					//return float4(intensity* lightIntensity,intensity* lightIntensity,lightIntensity,color.a);
 					//return float4(textureColor0.rgb,intensity*color.a); // show gradient
				}
			}
  			else
				intensity = textureColor0.r; // gray Texture 

			if (useTransferTexture) 
			{
				// use transfer functions
				float4 colorLookup = texture1.Sample(samp_texture1,float2(intensity,0.0));
				intensity = colorLookup.a;	 // mm 
  				intensity =  clamp((intensity - intensityWindow.x) / (intensityWindow.y-intensityWindow.x),0,1);


				// Diffuse shading and fake ambient lighting
				colorLookup.rgb = lightIntensity * colorLookup.rgb + 0.1f * colorLookup.rgb;

				// Front to back blending
				colorLookup.rgb *= intensity;		  //  *color.a == slider 
				colorSum += (1 - colorSum.a) * colorLookup;


			}
			else 
			{
				// add scaling and clipping to window 
				intensity =  (intensity - intensityWindow.x)/ (intensityWindow.y-intensityWindow.x);
				float4 src = float4(lightIntensity,lightIntensity,lightIntensity,intensity);
				src.a *= color.a; // use transparency from slider 
				src.rgb *= src.a;
				colorSum = (1.0f - colorSum.a)*src + colorSum;
 				    
			}

			rayPosition += rayDirection;

			if (colorSum.a>=0.97 || rayPosition.x > 1.0f || rayPosition.y > 1.0f || rayPosition.z > 1.0f
				|| rayPosition.x < 0.0f || rayPosition.y < 0.0f || rayPosition.z < 0.0f)
				break;

		}

		color = colorSum;
		intensity = colorSum.a;
		//clip(((intensity<=0.01 ) || (intensity>1.0)) ? -1.0 : 1.0);	

		//clip((color.a <= AlphaRef) ? -1.0 : 1.0);
		return color;
	}

	"
}

#DEF VolumeShaderRayCasting PackagedShader 
#{

###	exposedField SFVec2f	   intensityWindow 0.1 1.0

#	language "xxxxFX"


#	url "xxxxRayCasting.fx"
#}
]
}

DEF ROOT  Group	{

}

NavigationInfo 
{
	headlight TRUE 
	speed 1
	type [ "EXAMINE" "ANY" ]
	avatarSize [0.01 0.1 0.1 ]
}


DEF B1 Background {     
	skyColor 0 0 0
}


DEF SELECTION Selection {
	# walk through , don't pick me
	select FALSE
	collide	FALSE
	children
	DEF Volume Transform 
	{

		children 
		
		DEF DRAW-GROUP DrawGroup {
			sortedAlpha	FALSE
			restoreOp TRUE 

			children [

				# add blend together all layers 
				DEF BLENDOP DrawOp {
					op [
						0 0
						1 0 # no z write  
						2 8
						3 1 # alpha test on, to save pixel writing 
						4 4 # alpha cmp Less Equal
						5 1 # alpha ref 
						6 1 # blend 
						7  6   # src blend mode	  Multiply 1- minus src alpha = scale 
                		8  2   # dst blend mode	  # add 

					]
				}



				DEF ROOT-SHAPE Shape 
				{
					appearance DEF APP Appearance 
					{
						material DEF MAT Material {
							emissiveColor 1 1 1 #0.5 0.5 0.5
							diffuseColor 0 0 0
							transparency 0.05 # blend only a small fraction per layer  
						}
						texture DEF mt MultiTexture {
							#alpha 0.9 # multiply all colors with 0.1 first 
							mode [
								"MODULATE"
								###"FACTOR_MODULATE,SELECTARG2" # BLENDFACTORALPHA" 
							]

							texture	[USE dicom	 ]
						
						}
						## texture	USE dicom
						shaders [ 
							
								 #USE BasicVolumeShader	
								 USE BasicVolumeShaderRayCast
								 # USE BasicVolumeShaderDX11
								]
					
						
					}
	

				}

				# reset draw ops 
				DrawOp {
					op [
						0 1
						1 1  
						2 2
						6 0 # blend 
						7  6   # src blend mode	  Multiply 1- minus src alpha = scale 
                		8  2   # dst blend mode	  # add 

					]
				}
			] 
		}

	
	}
}



# rest is some UI stuff
DEF LAYER_SLIDERS Layer3D	{
	size 1 1 
	children
DEF SLIDERS Group 
{
	children [
		Transform {
			translation	-0.5 0 0
			children [
		DirectionalLight { direction 0.6 0 -1 }
		Transform {
			translation	-0.8 0 0
			
			scale 0.5 0.5 0.5 

			children DEF TRANSPARENCY Slider { 
				description "Transparency"
				min 0.0 max 1.0  
				initial_position 0.05
				pageSize 0.05
				radiusStick	0.025
				radiusKnob 0.05

			}
		}



		Transform {
			translation	-0.9 0 0
			scale 0.5 0.5 0.5 
			children DEF SLICE_START Slider	{ 
				description "End Slice"
				min 0.0 max 1  
				initial_position 1
				pageSize 0.05
				radiusStick	0.025
				radiusKnob 0.05

			}
		}
		Transform {
			translation	-1 0 0
			scale 0.5 0.5 0.5 

			children DEF SLICE_END Slider	{ 
				description "Start Slice"
				min 0.0 max 1  
				initial_position 0
				pageSize 0.05
				radiusStick	0.025
				radiusKnob 0.05

			}
		}


		Transform {
			translation	-1.1 0 0
			scale 0.5 0.5 0.5 

			children DEF WINDOW_START Slider	{ 
				description "Gray start"
				min 0.0 max 1  
				initial_position 0.1
				pageSize 0.05
				radiusStick	0.025
				radiusKnob 0.05

			}
		}
		Transform {
			translation	-1.2 0 0
			scale 0.5 0.5 0.5 

			children DEF WINDOW_END Slider	{ 
				description "Gray end"
				min 0.0 max 1  
				initial_position 1
				pageSize 0.05
				radiusStick	0.025
				radiusKnob 0.05

			}
		}
		Transform {
			translation	-1.3 0 0
			scale 0.5 0.5 0.5 

			children DEF NUM_STEPS Slider	{ 
				description "Num Raycast Steps"
				min 0.0 max 1.0 
				initial_position 0.5
				pageSize 0.05
				radiusStick	0.025
				radiusKnob 0.05

			}
		}
	]
}

	]
}
}

# hg UI protos borrowed from city show case
EXTERNPROTO CheckButton
[
	exposedField MFString name
	exposedField SFVec3f pos
	exposedField MFInt32	state
	eventOut MFInt32 state_out

]
["protos/checkbutton.wrl#CheckButton"]

EXTERNPROTO	RadioButtonGroup
[
	exposedField MFString	title
	exposedField SFVec3f	pos # x,y: offset of the line; z : offset of the button
	exposedField SFInt32	current #the first check button
	exposedField MFString	names
	exposedField SFInt32 visibility
]
["protos/radiobuttongroup.wrl#RadioButtonGroup"]


EXTERNPROTO Slider1[
	exposedField MFString name
	exposedField SFVec3f pos
	eventOut MFInt32 state_out
	exposedField SFVec2f range
	exposedField SFInt32 current
]
"protos/slider.wrl#Slider"



EXTERNPROTO pointOfInterest
[
	exposedField SFVec3f position
	exposedField MFString textureUrl
]
"protos/pointsOfInterest.wrl#pointOfInterest"



EXTERNPROTO	POIView
[
	exposedField SFVec3f poi_position
	exposedField SFVec3f vp_position
	exposedField SFRotation	vp_orientation
	exposedField SFString	vp_name
	exposedField MFString	title
	exposedField SFVec2f title_pos
	exposedField MFString	image_info
	exposedField MFString	thumbnail
	exposedField SFVec2f img_size
	eventOut MFString	image_info_out
]
"protos/pointsOfInterest.wrl#POIView"



EXTERNPROTO TextArea[
	exposedField MFString text 
	exposedField SFVec3f pos
	exposedField SFInt32 width
]
"protos/textarea.wrl#TextArea"

EXTERNPROTO	InterfaceLayer
[
	exposedField SFInt32 width
	exposedField MFNode	elements
]
["protos/interface_layer.wrl#InterfaceLayer"]


InterfaceLayer
{
	width 300
	elements
	[
		#DEF old_new_rbg RadioButtonGroup { title "New and old buildings" names ["Old", "New"] pos 10 100 200}
#		DEF slider_trees Slider1 { range 0 10 current 5 name "Trees animation" pos 20 -180 30}
#		DEF sun_pos Slider { range 0 10 current 5 name "Sun position" pos 20 -260 30}
#		DEF	ta TextArea	{
#			pos	20 350 20
#			text ["exposedField SFVec3f bboxSize", "exposedField SFVec3f bboxSize", "exposedField SFVec3f bboxSize"]	
#		}


DEF VOLUME_STYLE RadioButtonGroup
{
	pos	5 300 300
	current	0
	title	"Volume Style"

	names	["Sliced Axes", "Raycast Box", "Raycast Slice" "One Slice Axes" "Sliced View"]

}

DEF BTN_TRANSFER CheckButton{ 
	pos 25 100 300 
	state [4  0 ]
	name "Transfer Function" 
}

DEF BTN_SHADING CheckButton{ 
	pos 25 70 300 
	state [5  0 ]
	name "Shading" 
}

DEF BTN_NEXT CheckButton{ 
	pos 25 10 300 
	state [6  0 ]
	name "Next Volume" 
}


	]
}

# configure rendering / style / shader 

DEF	DICOMScript Script
{

	directOutput TRUE
	field SFNode dicom USE dicom
	eventIn	SFBool isLoaded			# when DICOM//DDS is loaded, textures available 

	eventIn	SFFloat transparency
 
	eventIn	SFFloat sliceStart		# for slice geometry 
   	eventIn	SFFloat sliceEnd

	eventIn	SFFloat intensityStart	# intensity (gray) window min max 
   	eventIn	SFFloat intensityEnd

	eventIn	SFFloat setNumSteps 	# set num ray cast steps

	eventIn SFInt32 setVolumeStyle
	eventIn MFInt32 setButtonState


	## shader config
	exposedField SFBool	isGradientTexture FALSE

	exposedField SFBool	useTransferTexture FALSE

  	exposedField SFBool	useShading FALSE
	exposedField SFInt32 numRaycastSteps 256 ## 256 #  128 ## 64 ## 64 ##128		  128 fails with shading + lookup 



	field SFNode tm DEF TM TextureMatrixTransform 
	{
		matrix  1 0 0 0
		0 1 0 0
		0 0 1 0
		0 0 0 1
	}	
	field SFNode app USE APP

	field SFNode shape USE ROOT-SHAPE

  	field SFNode drawGroup USE DRAW-GROUP

	field SFNode blendOp USE BLENDOP

	field SFNode blendOpNOZWrite
		DEF BLENDOP_NOZWRITE DrawOp {
					op [
						0 0
						1 0 # no z write  
						2 8
						3 1 # alpha test on, to save pixel writing 
						4 4 # alpha cmp Less Equal

					]
				}

	field SFNode shader USE BasicVolumeShader
	field SFNode shaderRayCast USE BasicVolumeShaderRayCast
	field SFNode shaderDX11 USE BasicVolumeShaderDX11
	field SFNode shaderRayCastDX11 USE BasicVolumeShaderRayCastDX11


	field SFNode transparencySlider   USE TRANSPARENCY

	#field SFNode SLICE_START
	#field SFNode SLICE_END


	#field SFNode WINDOW_START
	#field SFNode WINDOW_END

	field SFInt32 fileIndex 0

	field MFString files  [
		"VolumeMaps/VisMale.Gradient.dds"
		"VolumeMaps/HeadVolume.dds"
		"VolumeMaps/NoiseVolume.dds"

		"D:\\Bitmanagement\\Customers\\Boldt Zahnarzt\\2017-12-12-DICOM\\DICOMDIRGradient.dds"

		"VolumeMaps/MR-MONO2-8-16x-heart.dcm"
 		"VolumeMaps/MR-MONO2-8-16x-heart.dds"

## slower		"D:\\Bitmanagement\\Customers\\Boldt Zahnarzt\\2017-12-12-DICOM\\DICOMDIR"

	]



	url	"vrmlscript:

	function printMeta(ms)
	{
		var spacing; // 
		var origin;
		if (ms) {
	   		for (var i=0; i<ms.value.length; i++) 
			{
				var n = ms.value[i];
				print(n.name+':'+n.value);
				if (n.getType() == 'MetadataSet')
				{
					printMeta(n);
				}
				if (n.name == 'Spacing')
					spacing = n.value;

			 	if (n.name == 'Origin')
					origin = n.value;
			}
		}
	}

	function isLoaded(f)
	{

		print('DICOM loaded:'+f);
		print(' url:'+dicom.url);

		if (!f)
			return; 
		
		print(' # textures:'+dicom.texture.length);
		var ms=dicom.metadata;
		var spacing; // 
		var origin;
		if (ms) {
	   		for (var i=0; i<ms.value.length; i++) 
			{
				var n = ms.value[i];
				print(n.name+':'+n.value);
				if (n.getType() == 'MetadataSet')
				{
					printMeta(n);
				}
				if (n.name == 'Spacing')
					spacing = n.value;

			 	if (n.name == 'Origin')
					origin = n.value;
			}
		}
		for (var i=0; i<dicom.texture.length; i++) 
		{
			var n = dicom.texture[i];
			print(' Tex :'+n.getType());

		}

		if (dicom.volumeTexture)
		{
			//app.textureTransform = tm;
			print(' volumeSizePixel:'+dicom.volumeSizePixel);

		}
		else {
			dicom.selected= 0; // use first 
		}
		if (dicom.transferTexture)
		{
			//app.textureTransform = tm;
			print('transferTexture:'+dicom.transferTexture.getType());
			app.texture.texture[1] = dicom.transferTexture;

		}
		// use created Planes 
		if (dicom.volumeGeometry)
		{
			//app.textureTransform = tm;
			shape.geometry =  dicom.volumeGeometry;
  		}
		
		print(' volumeStyle:'+dicom.volumeStyle);

		configureVolumeStyle(dicom.volumeStyle);
 
		if (app.shaders.length >0)
		{
			var n = app.shaders[0];
			print('current Shader is :'+n.getName());
		}

	}

	function configureShader(style)
	{
	    isGradientTexture = dicom.hasGradient;

		if (useTransferTexture && dicom.transferTexture)
		{
			//app.textureTransform = tm;
			print('transferTexture:'+dicom.transferTexture.getType());
			app.texture.texture[1] = dicom.transferTexture;

		}
		else  {
			app.texture.texture.length = 1;		
			useTransferTexture = false;
		}

		// shader preamble 
		var s='\n';
		s+='static const bool isGradientTexture = '+(isGradientTexture ? 'true':'false')+';\n'; 
		s+='static const bool useTransferTexture = '+((useTransferTexture && dicom.transferTexture) ? 'true' : 'false')+';\n'; 
   		s+='static const int numSteps  = '+	numRaycastSteps	+';\n';
		s+='static const bool useShading = '+((useShading && isGradientTexture) ? 'true' : 'false')+';\n'; 

		print('ShaderConfig:'+s);
		if (app.shaders[0])
		{

   
			var n = app.shaders[0];
			print('current Shader is :'+n.getName());


			var news;
			news=app.shaders[0].url[0];
			var i=news.indexOf('//CONFIG END');
			if (i>=0 && news.substring(0,3)	== 'fx:')
			{
				// add config 
				s = 'fx:' + s + news.substring(i);
				app.shaders[0].url[0] = s;

			}
			if (i>=0 && news.substring(0,5)	== 'hlsl:')
			{
				// add config 
				s = 'hlsl:' + s + news.substring(i);
				app.shaders[0].url[0] = s;

			}
		}

	}
	function configureVolumeStyle(style)
	{
	    isGradientTexture = dicom.hasGradient;
		var renderer = Browser.getCap(29);
		print('renderer:'+renderer);



		if (style == 0 || style == 4) {	 // slices 
			drawGroup.children[0]=blendOp; //additive blending
			app.shaders[0]=shader;
			if (renderer == 7)
			    app.shaders[0]=shaderDX11;

			app.material.transparency = 1.0 * 1.0/dicom.numSlices;	 // depending on iterations 

			transparencySlider.set_position= app.material.transparency;
 			transparencySlider.set_unfiltered_position= app.material.transparency;

 		}
		if (style == 1) {		//  ray cast  box 
			drawGroup.children[0]=null; // no blending
			drawGroup.children[0]=blendOpNOZWrite;	  // still check clip in shader 
			app.shaders[0]=	 shaderRayCast;
			if (renderer == 7) {
				app.shaders[0]=shaderRayCastDX11;
			}
			else {
				//if (useShading && numRaycastSteps>64)
				//	numRaycastSteps=64;
				//else
				//   if (numRaycastSteps>128)
				//	 numRaycastSteps = 128;
			}
			
			app.material.transparency = 0;	 // not used // depending on raycast iterations 

			transparencySlider.set_position= app.material.transparency;
 			transparencySlider.set_unfiltered_position= app.material.transparency;

 		}
		if (style == 2) {	   // ray cast 
			drawGroup.children[0]=null; // no blending
			drawGroup.children[0]=blendOpNOZWrite;
			app.shaders[0]=	 shaderRayCast;
			if (renderer == 7)
				app.shaders[0]=shaderRayCastDX11;
			app.material.transparency = 0.0;	 // depending on iterations 

			transparencySlider.set_position= app.material.transparency;
 			transparencySlider.set_unfiltered_position= app.material.transparency;
  			//transparencySlider.silently_set_position= app.material.transparency;
		
		
 		}
		if (style == 3) {		   // just a slice 
			drawGroup.children[0]=null; // no blending
			app.shaders[0]=	 shader;
			if (renderer == 7)
			    app.shaders[0]=shaderDX11;

			app.material.transparency = 0.0;	
			transparencySlider.set_position= app.material.transparency;
 			transparencySlider.set_unfiltered_position= app.material.transparency;
  			//transparencySlider.silently_set_position= app.material.transparency;
		 
 		}
		

		// confiugre shader 
		configureShader(style);

			
		Browser.print('Intensity range:'+ shader.intensityWindow);
		Browser.print('Transparency:'+ app.material.transparency);
	
 		Browser.print('Slice range:'+  dicom.sliceRange + ' Number of Slices:'+dicom.numSlices);

		Browser.print('Has Gradient:'+ dicom.hasGradient);


	}
	function setVolumeStyle(style)
	{

	   print('Set VolumeStyle :'+style);
	   dicom.volumeStyle = style;
	   configureVolumeStyle(style);
	}
	function setButtonState(state)
	{

	   print('setButtonState :'+state);

  		if (state[0] == 6)
		{

			fileIndex ++;
			if (fileIndex>=files.length)
				fileIndex = 0;

			print('New Dataset:'+ files[fileIndex]);

			dicom.url= new MFString(files[fileIndex]);

			return;

		}

	   if (state[0]== 4)
			useTransferTexture = state[1];
   	   else if (state[0]== 5)
			useShading = state[1];

	   configureShader(dicom.volumeStyle);

	   //configureVolumeStyle(dicom.volumeStyle);
	}
	
	function selectNext()
	{
		var i=0;
		if (i>0 && i <<dicom.texture.length)
		{
			var n = dicom.texture[i];
			print(':'+n.getType());
			dicom.volumeTexture = n;

		}
	}

	function transparency(v)
	{
		
		Browser.print('Transparency:'+ v);
		app.material.transparency = v;
		return;

		if (v >= 0.99)
			blendOp.op[6*2+1] = 0; // blend off 
		else 
			blendOp.op[6*2+1] = 1; // blend on 

	}

	function sliceStart(v)
	{
		dicom.sliceRange.x = v;
		Browser.print('Slice range:'+  dicom.sliceRange + ' Number of Slices:'+dicom.numSlices);

	}
	function sliceEnd(v)
	{
		dicom.sliceRange.y = v;
		Browser.print('Slice range:'+  dicom.sliceRange + ' Number of Slices:'+dicom.numSlices);

	}
	
	function intensityStart(v)
	{
		shader.intensityWindow.x = v;
		shaderRayCast.intensityWindow.x = v;
		shaderDX11.intensityWindow.x = v;
  		shaderRayCastDX11.intensityWindow.x = v;
		Browser.print('Intensity range:'+ shader.intensityWindow);
	}
	function intensityEnd(v)
	{
		shader.intensityWindow.y = v;
		shaderRayCast.intensityWindow.y = v;
		shaderDX11.intensityWindow.y = v;
		shaderRayCastDX11.intensityWindow.y = v;
		Browser.print('Intensity range:'+ shader.intensityWindow);
  	}

	function setNumSteps(v)
	{
		var oldv=numRaycastSteps;
		v*=512;

		if (v>1 && v <=1024)
			numRaycastSteps = v;
		if (numRaycastSteps != oldv) 
		{

			//shader.intensityWindow.y = v;
			//shaderRayCast.intensityWindow.y = v;
			//shaderDX11.intensityWindow.y = v;
			//shaderRayCastDX11.intensityWindow.y = v;
			 configureShader(dicom.volumeStyle);
			Browser.print('numRaycastSteps:'+ numRaycastSteps);
		}
	}
	"
}

ROUTE dicom.isLoaded TO	DICOMScript.isLoaded

## done in DICOM script 
	
ROUTE TRANSPARENCY.position_changed	TO	 MAT.transparency


ROUTE TRANSPARENCY.position_changed	TO DICOMScript.transparency

ROUTE SLICE_START.position_changed	TO DICOMScript.sliceEnd ## top 
ROUTE SLICE_END.position_changed	TO DICOMScript.sliceStart ## bottom 


ROUTE WINDOW_START.position_changed	TO DICOMScript.intensityStart  
ROUTE WINDOW_END.position_changed	TO DICOMScript.intensityEnd  
ROUTE NUM_STEPS.position_changed	TO DICOMScript.setNumSteps  


ROUTE VOLUME_STYLE.current TO	DICOMScript.setVolumeStyle   
ROUTE BTN_TRANSFER.state_out TO DICOMScript.setButtonState
ROUTE BTN_SHADING.state_out TO DICOMScript.setButtonState
ROUTE BTN_NEXT.state_out TO DICOMScript.setButtonState



#controller from html 
#obsolete 

DEF	blender Script
{
	directOutput TRUE

	eventIn	SFString set_blendmode1
	eventIn	SFString set_blendmode2
	eventIn	SFString set_blendmode3
	eventIn SFString set_bumpTexMode

	eventIn	SFString set_tex1
	eventIn	SFString set_tex2
	eventIn	SFString set_tex3

	eventIn	SFString set_texgen1

	field SFNode mtNode USE	mt
	field SFNode texGenNode NULL ## USE	TEX-GEN

	field SFNode material USE  MAT
	field SFNode blendOp USE  BLENDOP

	field MFString nuMode ["", ""]

	field SFString blendModes ""
	field SFString status ""

	url"vrmlscript:

	function initialize() 
	{   
		var b=Browser.getName();
		var version=parseFloat(Browser.getVersion());

		if ((b == 'bsContact')) 
		{ 
			blendModes= Browser.getOption('textureBlendModes');
			//print('textureBlendModes:'+blendModes);
		}

		//if (blendModes.lastIndexOf('BUMPENVMAP')<0) 
		//	print('Bump mapping not supported, demo will not work ');
	
		// get current mode 
		nuMode = mtNode.mode;
		set_blendop('add');
	}

	// set type of blending 
	// see also http://www.sgi.com/software/opengl/advanced98/notes/node228.html
	function set_blendop(s)
	{
		var ofs=7*2;
		if (s == 'add') {  // add alpha 
			blendOp.op[ofs+1]=6;
			blendOp.op[ofs+3]=2;
		} 
		else 	
			if (s == 'over') {
			// GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
			blendOp.op[ofs+1]=6;
			blendOp.op[ofs+3]=5;
		}
		else 	
			if (s == 'under') {
			//material.emissiveColor = new SFColor(1,1,1);

			// GL_ONE_MINUS_DST, GL_DST
			blendOp.op[ofs+1]=10;
			blendOp.op[ofs+3]=9;
		}
		else if (s == 'max') {
			// looks good 

			material.emissiveColor = new SFColor(1,1,1);

			blendOp.op[ofs+1]=2;
			blendOp.op[ofs+3]=2;   // BLEND_ONE             
			blendOp.op[ofs+4]=62; // BLENDOP
			blendOp.op[ofs+5]=5;  // BLENDOP_MAX
		} 
		else if (s == 'attenuate') {
			material.emissiveColor = new SFColor(1,1,1);

			blendOp.op[ofs+1]=14;  // BLEND_BLENDFACTOR     
			blendOp.op[ofs+3]=2;   // BLEND_ONE             
			blendOp.op[ofs+4]=62; // BLENDOP
			blendOp.op[ofs+5]=1;  // BLENDOP_ADD          
		} 

		print('current blendop: '+s);
	}

	function set_blendmode1(s, t)
	{
		nuMode[0] = s;
		mtNode.mode = nuMode; 
		print('current blendmode 1: '+nuMode);
		mode1Mem = s; 
	
	}
	function set_blendmode2(s, t)
	{
		nuMode[1] = s;
		mtNode.mode = nuMode;
		print('current blendmode 2: '+nuMode);
	}
	function set_blendmode3(s, t)
	{
		nuMode[2] = s;
		mtNode.mode = nuMode;
		print('current blendmode 3: '+nuMode);
	}

	// change texture urls 
	function set_tex1(s, t)
	{
		if ( (mtNode.texture.length <1) || !mtNode.texture[0]) {
			mtNode.texture[0] = new SFNode('ImageTexture {}');
		}

		mtNode.texture[0].url[0]=s; 
		print('current texture url 1: '+s);
	}
	function set_tex2(s, t)
	{
		print(s);
		if (s.length == 0) {
			mtNode.texture.length = Math.min(1,mtNode.texture.length);
			return;
		}

		if ( (mtNode.texture.length <=1) || !mtNode.texture[1]) {
			mtNode.texture[1] = new SFNode('ImageTexture {}');
		}
		mtNode.texture[1].url[0]=s; 
		print('current texture url 2: '+s);
	}
	function set_tex3(s, t)
	{
		if (s.length == 0) {
			mtNode.texture.length = Math.min(2,mtNode.texture.length);
			return;
		}

		if ((mtNode.texture.length <=2) || !mtNode.texture[2]) {
			mtNode.texture[2] = new SFNode('ImageTexture {}');
		}
		mtNode.texture[2].url[0]=s; 
		print('current texture url 3: '+s);
	}


	function set_bumpTexMode(s, t)
	{
		if (!mtNode.texture[1]) {
			mtNode.texture[1] = new SFNode('ImageTexture {}');
		}
		mtNode.texture[1].parameter[0]=s;
		print('current bump texture type : '+	mtNode.texture[1].parameter);

	}
	function set_texgen1(s, t)
	{
		texGenNode.mode=s;
		print('current texcoord gen mode : '+	texGenNode.mode);

	}

	"
}

################ DropHandler
DropHandler	{ 
	root USE ROOT	
	rootShape	USE ROOT-SHAPE 
}


